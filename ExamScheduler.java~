import structure5.*;
import java.util.Iterator;
import java.util.Scanner;

class ExamScheduler{

  
  /* parses a file where the first line is the student name and the next fourl lines
   * are the classes being taken by that student. such a file is parsed and a vector of
   * students is created
   * 
   * @Pre: filename is a valid file
   * @Post returns a vector containing Student objects
   */ 
  private Vector<Student> parseSchedules(String filename){
    
     Scanner in = new Scanner(new FileStream(filename));
     Vector<Student> vs = new Vector<Student>();
     
     while(in.hasNextLine()){
       vs.add(new Student(in.nextLine(), in.nextLine(), in.nextLine(), in.nextLine(), in.nextLine()));
       
     }
     return vs;
  }
  
  /* creates a graph where the verticies are classes and the edges between verticies
   * are the number of students taking both of those classes
   * 
   * @Pre: v is not empty
   * @Post: returns an undirected graph that contains the schedules of the students
   */ 
  private GraphListUndirected createGraph(Vector<Student> v){
    
    GraphListUndirected<String, Integer> g = new GraphListUndirected<String,Integer>();
    String [] c;
    
    for (Student s : v){
      
      c = s.getClasses();
      
      for (String st : c) g.add(st);
     
      for (int x = 0; x < 4; x++){
        for (int y = 0; y < 4; y++){
          if (y != x) g.addEdge(g.get(c[x]), g.get(c[y]), 1);
        }
      } 
    }
    return g;
  }
  
  /* prints the graph as an adjacency matrix
   * 
   * @Pre: The graph is not empty
   * @Post: prints an adjacency matrix where each line is
   */ 
  public void printGraph(GraphListUndirected<String, Integer> g){
    
    Iterator<String> i = g.iterator();
    
    while (i.hasNext()){
      String vertex = i.next();
      String line = vertex + "->";
      Iterator<String> n = g.neighbors(vertex);
      while (n.hasNext()){
        line += n.next() + " ";
      }
      System.out.println(line);
    }
  }
  
  
  /* prints the schedule generated by the getSchedule method
   * 
   * @Pre: vector is not empty
   * @Post: prints each association as a line with the slot -> class
   */ 
  public void printSchedule(Vector<Association<Integer, String>> v){
    
    int slot = 1;
    for(Association a : v){
      System.out.println("Slot " + a.getKey() + " -> " + a.getValue());
    }
  }
  
  /*creates a schedule using a graph
   * 
   * @Param: a graph whose vertexes are classes and edges are the number of students taking
   * both classes the edge connects
   * @Pre: graph is not blank
   * @Post: returns a vector of associations contining an integer representing a timeslot
   * and the name of the class in that timeslot as the key
   */ 
  private Vector<Association<Integer, String>> getSchedule(GraphListUndirected<String,Integer> g){
    
    int slot = 1;
    String next = getSmallestDegree(g);
    Vector<Association<Integer, String>> v = new Vector<Association<Integer, String>>();
    Vector<String> currentSlotVector = new Vector<String>(5);
    g.visit(g.get(next));
    currentSlotVector.add(next);
    v.add(new Association<Integer, String>(slot, next));
    
    while(true){
      next = getNextVertex(g, currentSlotVector);
      if (next!= ""){
        v.add(new Association<Integer, String>(slot, next));
        g.visit(g.get(next));
        currentSlotVector.add(next);
      }
      else if (next == "" && currentSlotVector.isEmpty()) break;
      else {
        currentSlotVector.clear();
        slot++;
      }
    }
    g.reset();
    return v;
  }
  
  /* fetches a vertex label for the getSchedule method which represents a class that doesn't conflict
   * with any classes in the current timeslot
   * 
   * @Param: a graph of classes, and a vector containing all the classes in the current timeslot
   * @Pre: graph is not blank
   * @Post: returns a string label that doesn't conflict with any of the classes in currentClasses
   */ 
  private String getNextVertex(GraphListUndirected<String, Integer> g, Vector<String> currentClasses){
    
    Iterator<String> i = g.iterator();
    
    String nextVertex = "";
    
    while(i.hasNext() && nextVertex == ""){
      String testVertex = i.next();
      if(!g.isVisited(testVertex) && getNextVertexHelper(g, currentClasses, testVertex)) nextVertex = testVertex;
    }
    
    while (i.hasNext()){
      String testVertex = i.next();
      if(!g.isVisited(testVertex) && getNextVertexHelper(g, currentClasses, testVertex) 
           && g.degree(nextVertex) > g.degree(testVertex)) nextVertex = testVertex;
    }
    return nextVertex;
  }
  
  /* helper method for getNextVertex. returns true if testVertex doesn't 
   * have any neighbors present in currentClasses
   * 
   * @Param: graph containing classes, vector containing classes in the 
   * current timeslot, string label of the vertex being considered
   * @Pre: graph is not empty, textVertex is a valid vertex
   * @Post: returns true if testVertex doesn't conflict with the classes in currentClasses
   */ 
  private Boolean getNextVertexHelper(GraphListUndirected<String, Integer> g, Vector<String> currentClasses, String testVertex){
  
    Iterator<String> n = g.neighbors(testVertex);
    while(n.hasNext()){
      if(currentClasses.contains(n.next())) return false;
    }
    return true;
  }
  
  /* returns the smallest degree vertex to start the scheduling process
   * 
   * @Param: a graph contining classes
   * @Pre: graph is not blank
   * @Post: returns the label of the smallest degree vertex in the graph
   */ 
  private String getSmallestDegree(GraphListUndirected<String, Integer> g){
    
    Iterator<String> i = g.iterator();
    
    String smallestDegree = i.next();
    
    while (i.hasNext()){
      String testVertex = i.next();
      
      if(g.degree(smallestDegree) > g.degree(testVertex)) smallestDegree = testVertex;
    }
    return smallestDegree;
  }
  
  /* prints the best possible exam schedule
   * 
   * note: this creates an iterator that iterates through all possible permutations
   * of the vector of classes. the number of permutations is the factorial of the vector
   * size. any vector over 10 should not be attempted
   * 
   * @Param: a graph of the classes
   * @Pre: the graph is not blank
   * @Post: returns a vector of associations containing the best possible schedule
   */ 
  private Vector<Association<Integer, String>> getBestSchedule(GraphListUndirected<String,Integer> g){
    
    Iterator<String> i = g.iterator();
    Vector<String> v = new Vector<String>(20);
    while (i.hasNext()) v.add(i.next());
    
    Iterator<Vector<String>> iter = new Permute(v.iterator());
    
    Vector<String> bestSchedule = iter.next();
    Vector<String> testSchedule; 
    Vector<String> runningSchedule = new Vector<String>(5);
    Vector<Association<Integer, String>> returnSchedule = new Vector<Association<Integer, String>>(v.size());
    int slot = 1;
    int bestSlot = v.size();
    
    while (iter.hasNext()){
       testSchedule = iter.next();
       runningSchedule = new Vector<String>();
      for(String s : testSchedule){
        
        g.visit(g.get(s));
        
        if (getNextVertexHelper(g, runningSchedule, s)) runningSchedule.add(s);
        else {
          runningSchedule.clear();
          runningSchedule.add(s);
          slot++;
        }
      }
      if (slot < bestSlot){
        bestSchedule = new Vector(testSchedule);
        bestSlot = slot;
      }
      g.reset();
      slot = 1;
    }
    
    runningSchedule.clear();
    
    for (String str : bestSchedule){
      g.visit(g.get(str));
      if (getNextVertexHelper(g, runningSchedule, str)){
        returnSchedule.add(new Association<Integer, String>(slot, str));
        runningSchedule.add(str);
      }
      else{
        slot++;
        returnSchedule.add(new Association<Integer, String>(slot, str));
        runningSchedule.clear();
        runningSchedule.add(str);
      }
    }
    g.reset();
    return returnSchedule;
  }
  
  /* Prints out the exam schedule in alphabetical order
   * 
   * @Param: vector of associations with the time slot number as the key and class as value
   * @Pre: vector is not empty
   * @Post: prints the exam schedule in alphabetical order
   */ 
  public void printOrderedSchedule(Vector<Association<Integer, String>> v){
    Vector<Association<Integer, String>> returnVector = new Vector<Association<Integer, String>>(v.size());
    OrderedVector<String> ordV = new OrderedVector<String>();
    int order = 1;
    
    for(Association<Integer, String> a : v) ordV.add(a.getValue());
    for(String s : ordV){
      
      for(Association<Integer, String> ass : v){
        if (ass.getValue().equals(s)){
          returnVector.add(new Association<Integer, String>(ass.getKey(), ass.getValue()));
          break;
        }
      }
    }
    printSchedule(returnVector);
  }
  
  public static void main(String[] args){
    
    ExamScheduler e = new ExamScheduler();
    
    Vector students = e.parseSchedules(args[0]);
    GraphListUndirected<String, Integer> gr = e.createGraph(students);
    
    e.printGraph(gr);
    e.printSchedule(e.getSchedule(gr));
    System.out.println();
    e.printSchedule(e.getBestSchedule(gr));
    System.out.println();
    e.printOrderedSchedule(e.getSchedule(gr));
    
  }
  
}